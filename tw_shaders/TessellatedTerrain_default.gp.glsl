//Geometry program used by default rendering mode of TessellatedTerrain

#version 430 core

layout (triangles) in;	//Input data is interpreted as triangles
layout (triangle_strip) out;	//Output is interpreted as triangle strips
layout (max_vertices = 3) out;	//Maximal number of output vertices is 3

uniform vec3 Scale;						//Model scale factors
uniform mat4 ModelViewTransform;		//Model-View transform (includes scaling transform)
uniform mat4 ProjectionTransform;		//Projection transform

uniform sampler2DArray terrain_tex_sampler;		//terrain diffuse texture sampler

//Extra parameters generated by tessellation evaluation program
in TES_DATA
{
	vec2 texcoord;		//terrain texture coordinates
	vec3 normal;		//terrain vertex normals
}tes_in[];

//Extra parameters outputted by geometry shader
out GS_DATA
{
	vec4 texcoord;	//texture coordinates are passed through geometry shader
}gs_out;


void computeLightModelVertexData(vec4 v4Vertex, vec3 v3Normal, vec3 v3Tangent, vec3 v3Binormal);
mat3x3 computeTangentDirections(vec3 v3P0, vec3 v3P1, vec3 v3P2, vec2 v2P0_bm_coords, vec2 v2P1_bm_coords, vec2 v2P2_bm_coords);


	
void main()
{
	//Retrieve vertices of the currently processed primitive
	vec3 v3P0 = Scale*gl_in[0].gl_Position.xyz;
	vec3 v3P1 = Scale*gl_in[1].gl_Position.xyz;
	vec3 v3P2 = Scale*gl_in[2].gl_Position.xyz;

	//Compute cliff impact coefficient
	vec3 v3N = normalize(cross(v3P1 - v3P0, v3P2 - v3P0));
	float cliff_impact = 1.0f - abs(v3N.y);

	//Compute tangent and binormal vectors for the current primitive
	mat3x3 m3x3TB = computeTangentDirections(v3P0, v3P1, v3P2, tes_in[0].texcoord, tes_in[1].texcoord, tes_in[2].texcoord);
	vec3 v3T = vec3(m3x3TB[0][0], m3x3TB[0][1], m3x3TB[0][2]);
	vec3 v3B = vec3(m3x3TB[1][0], m3x3TB[1][1], m3x3TB[1][2]);
	
	unsigned int num_slices = unsigned int(textureSize(terrain_tex_sampler, 0).z);
	for(int i = 0; i < gl_in.length; ++i)
	{
		computeLightModelVertexData(vec4(Scale, 1.0f) * gl_in[i].gl_Position, tes_in[i].normal, v3T, v3B);
		gl_Position = ProjectionTransform * (ModelViewTransform * gl_in[i].gl_Position);
		gs_out.texcoord.st = tes_in[i].texcoord;
		
		
		float slice = gl_in[i].gl_Position.y * num_slices;
		gs_out.texcoord.p = slice;
		gs_out.texcoord.q = cliff_impact;
		
		EmitVertex();
	}
	EndPrimitive();
}