//Implements screen-space filters that can be arranged into filter cascades
//These filters are useful tools that provide foundation for such screen-space technologies as HDR-Bloom, screen-space crepuscular rays and SSAO

#ifndef TW__SSFILTER__


#include <array>
#include <list>
#include <bitset>
#include <initializer_list>
#include <cstdint>
#include <string>

#include "AbstractProjectingDevice.h"
#include "AbstractRenderingDevice.h"
#include "ImmutableTexture2D.h"
#include "FullscreenRectangle.h"
#include "SeparateShaderProgram.h"
#include "Framebuffer.h"
#include "ErrorBehavioral.h"


namespace tiny_world
{
	class CascadeFilter;	//forward declaration of CascadeFilter class;

	//Provides generic abstract interface for screen-space filters
	class AbstractSSFilter : public Entity
	{
		friend class CascadeFilter;

	protected:
		//Returns texture source associate with the given index
		virtual ImmutableTexture2D getTextureSource(uint32_t index) const = 0;

		//Sets new texture source for the given source index
		virtual void setTextureSource(uint32_t index, const ImmutableTexture2D& _2dtexture) = 0;


		//Default initialization
		explicit AbstractSSFilter(const std::string& ssfilter_class_name);

	public:
		//Initializes filter (note that the filters need to be reinitialized each time the output screen changes its size)
		virtual void initialize() = 0;

		//Returns 'true' if the filter has been initialized, returns 'false' otherwise
		virtual bool isInitialized() const = 0;

		//Executes filtering pass and outputs result as a "full screen rectangle" forwarded to the given render target
		virtual bool pass(const AbstractProjectingDevice& projecting_device, AbstractRenderingDevice& render_target) = 0;

		//Returns number of inputs required by the filter
		virtual uint32_t getNumberOfInputChannels() const = 0;
	};



	template<uint32_t num_2dtexture_sources>
	class SSFilter : public AbstractSSFilter
	{
	private:
		std::array<ImmutableTexture2D, num_2dtexture_sources> sources;		//source textures of the filter
		FullscreenRectangle canvas;		//canvas rectangle used by the filter to output its results
		SeparateShaderProgram filter_fragment_program;	//fragment shader implementing filtering
		bool is_initialized;	//this flag is set when the filter has been initialized

	protected:
		//This function injects actual filtering algorithm into the shader program that implements filtering.
		//In more detail, each SSFilter has a fragment shader associated with it, which defines function do_filtering(in sampler2D source_1, ... , in sampler2D source_N), but
		//provides no implementation. Therefore, an implementation must be provided by a derived class overriding this function. It is also allowed for the derived class to introduce certain
		//additional changes to the base shader program generated by SSFilter object, but there is not strict requirement. The function must return 'true' on success and 'false' on failure
		virtual bool inject_filter_core(SeparateShaderProgram& filter_fragment_program) = 0;


		//This function must be implemented by inherited objects. It is called within each filter pass and its natural usage is to set specific additional filter parameters implemented as GLSL uniforms.
		//Since some of such parameters may possibly be textures and inherited objects do not have easy access to the texture infrastructure of the canvas, it is needed for them to know which texture 
		//units can be safely used for bindings. Hence, the function is called with its int-argument containing the id of the first vacant texture unit, i.e. any texture unit with id higher or equal to vacant_texture_unit_id
		//can safely be used for filter-defined texture bindings. 
		//The second argument of the function contains pointer to the sampler object, which is used by 2D texture sources of the filter.
		//The function must return 'true' on success and 'false' on failure.
		virtual bool set_filter_parameters(const AbstractProjectingDevice& projecting_device, const AbstractRenderingDevice& render_target, 
			int vacant_texture_unit_id, const TextureSampler* _2d_texture_source_sampler) = 0;


		//This function is needed if filter implementation requires to perform its own initialization procedures that rely on complete initialization of the components of the parent class.
		//The parent class calls this function upon completion of its own initialization procedures as the last action in function initialize()
		virtual bool perform_post_initialization() = 0;


		//Returns pointer to the filtering shader program
		ShaderProgram* getFilterShaderProgram()
		{
			return &filter_fragment_program;
		}


		//Sets sampler object to be used by the canvas
		void setCanvasSampler(const TextureSampler& sampler)
		{
			canvas.installSampler(sampler);
		}


		//Returns alias texture object being the filter source at the given index. The index can not exceed maximum sources supported by the filter minus 1
		ImmutableTexture2D getTextureSource(uint32_t index) const override
		{
			if (index >= num_2dtexture_sources)
				throw(std::out_of_range{ "Unable to access SS-filter texture source: provided index is out of range" });

			return sources[index];
		}


		//Sets new texture to be the filter source at the given index. The index can not exceed maximum sources supported by the filter minus 1
		void setTextureSource(uint32_t index, const ImmutableTexture2D& _2dtexture) override
		{
			if (index >= num_2dtexture_sources)
				throw(std::out_of_range{ "Unable to update SS-filter texture source: index is out of range" });

			sources[index] = _2dtexture;
		}


		//Default initializer that creates new screen-space filter with undefined (possibly, incomplete) texture sources
		explicit SSFilter(const std::string& ssfilter_class_name) : AbstractSSFilter(ssfilter_class_name), is_initialized{ false }
		{

		}


		//Initializes new screen-space filter and defines its texture sources
		SSFilter(const std::string& ssfilter_class_name, std::array<ImmutableTexture2D, num_2dtexture_sources> sources) :
			AbstractSSFilter(ssfilter_class_name), is_initialized{ false }, sources{ sources }
		{

		}

	public:
		static const uint32_t number_of_input_channels = num_2dtexture_sources;


		//Initializes  screen-space filter. This function must be called before the filter is run for the first time.
		//NOTE: SS-filters must be re-initialized when screen size changes. Repetitive initializations are done in a lazy style, i.e. only parameters related to the canvas size get updated.
		void initialize() override
		{
			canvas.installTexture(sources[0]);	//this update is done regardless of the initialization state since the screen size may change and so should
												//the size of the base texture applied to the canvas

			if (is_initialized) return;

			//Generate source code for the filtering fragment shader. This needs to be done only once
			//This variable will store the full source code
			std::string fragment_shader_source_code =
				"#version 430 core\n";

			std::string sampler_declarations;	//this variable will contain declarations of the 2D texture sampler uniforms
			std::string do_filtering_fun_declaration = "vec4 do_filtering(";	//this variable will contain declaration of the do_filtering(...) function
			std::string do_filtering_fun_invocation = "do_filtering(";	//this variable will contain invocation of the do_filtering(...) function

			for (int i = 0; i < num_2dtexture_sources; ++i)
			{
				sampler_declarations += "uniform sampler2D source" + std::to_string(i) + ";\n";
				do_filtering_fun_declaration += "in sampler2D source" + std::to_string(i) + (i < num_2dtexture_sources - 1 ? ", " : ");\n");
				do_filtering_fun_invocation += "source" + std::to_string(i) + (i < num_2dtexture_sources - 1 ? ", " : ");\n");
			}

			fragment_shader_source_code += sampler_declarations;
			fragment_shader_source_code += do_filtering_fun_declaration;

			fragment_shader_source_code +=
				"out vec4 v4FragmentColor;\n"
				"void main()\n"
				"{\n"
				"v4FragmentColor = " + do_filtering_fun_invocation;
			fragment_shader_source_code += "}\n";

			Shader filtering_base_fragment_shader{ GLSLSourceCode{ fragment_shader_source_code.c_str(), fragment_shader_source_code.length() }, ShaderType::FRAGMENT_SHADER, "ssfilter_augmented_fragment_shader" };
			filter_fragment_program.addShader(filtering_base_fragment_shader);

			//Inject modifications introduced to the filtering shader by the inherited objects
			if (!inject_filter_core(filter_fragment_program))
			{
				set_error_state(true);
				const char* err_msg = "Can not generate filter fragment shader code";
				set_error_string(err_msg);
				call_error_callback(err_msg);
				return;
			}

			//Link the program
			filter_fragment_program.link();

			//Check if the program has been  linked correctly
			if (!filter_fragment_program)
			{
				set_error_state(true);
				std::string err_msg = std::string{ "Unable to link filtering shader fragment program: " } +filter_fragment_program.getErrorString();
				set_error_string(err_msg.c_str());
				call_error_callback(err_msg.c_str());
				return;
			}


			canvas.setFilterEffect(filter_fragment_program,
				[this](const AbstractProjectingDevice& projecting_device, const AbstractRenderingDevice& render_target, int texture_unit_start_id) -> bool
			{
				TextureUnitBlock* pTextureUnitBlock = AbstractRenderableObjectTextured::getTextureUnitBlockPointer();
				for (int i = 1; i < static_cast<int>(num_2dtexture_sources); ++i)
				{
					pTextureUnitBlock->switchActiveTextureUnit(texture_unit_start_id + i - 1);
					pTextureUnitBlock->bindTexture(sources[i]);
					pTextureUnitBlock->bindSampler(*pTextureUnitBlock->getBoundSampler(pTextureUnitBlock->getBindingTextureUnit(sources[0])));

					filter_fragment_program.assignUniformScalar("source" + std::to_string(i), i);
				}

				if (!set_filter_parameters(projecting_device, render_target, texture_unit_start_id + num_2dtexture_sources - 1, 
					pTextureUnitBlock->getBoundSampler(pTextureUnitBlock->getBindingTextureUnit(sources[0]))))
				{
					set_error_state(true);
					const char* err_msg = "Unable to set filter parameters";
					set_error_string(err_msg);
					call_error_callback(err_msg);
					return false;
				}

				return true;
			});


			//Perform post-initialization particulars
			if (!perform_post_initialization())
			{
				set_error_state(true);
				const char* err_msg = "Unable to complete initialization of the filter";
				set_error_string(err_msg);
				call_error_callback(err_msg);
				return;
			}


			is_initialized = true;
		}


		//Executes filtering pass and outputs result as a "full screen rectangle" forwarded to the given render target
		bool pass(const AbstractProjectingDevice& projecting_device, AbstractRenderingDevice& render_target) override
		{
			if (!is_initialized)
			{
				set_error_state(true);
				const char* err_msg = "Unable to run filter: the filter has not been initialized";
				set_error_string(err_msg);
				call_error_callback(err_msg);
				return false;
			}

			//Set location and dimensions of the canvas so that it covers the whole focal plane
			float left, right, bottom, top, near, far;
			projecting_device.getProjectionVolume(&left, &right, &bottom, &top, &near, &far);
			canvas.setLocation(vec3{ (left + right) / 2.0f, (bottom + top) / 2.0f, -near });
			canvas.setDimensions(right - left, top - bottom);

			//Apply view-projection transform to the canvas
			canvas.applyViewProjectionTransform(projecting_device);

			//Render canvas
			for (int i = 0; i < static_cast<int>(canvas.getNumberOfRenderingPasses(canvas.getActiveRenderingMode())); ++i)
			{
				if (!canvas.prepareRendering(render_target, i))
				{
					set_error_state(true);
					std::string err_msg = "Unable to prepare canvas for rendering at rendering pass " + std::to_string(i);
					set_error_string(err_msg.c_str());
					call_error_callback(err_msg.c_str());
					return false;
				}
				if (!canvas.render())
				{
					set_error_state(true);
					std::string err_msg = "Unable to render canvas at rendering pass " + std::to_string(i);
					set_error_string(err_msg.c_str());
					call_error_callback(err_msg.c_str());
					return false;
				}
				if (!canvas.finalizeRendering())
				{
					set_error_state(true);
					std::string err_msg = "Unable to finalize rendering of the canvas at rendering pass " + std::to_string(i);
					set_error_string(err_msg.c_str());
					call_error_callback(err_msg.c_str());
					return false;
				}
			}
			
			return true;
		}

		uint32_t getNumberOfInputChannels() const override { return number_of_input_channels; }

		//Returns 'true' if filter has been initialized. Returns 'false' otherwise.
		bool isInitialized() const override { return is_initialized; }
	};



	//The following classes describe infrastructure that can be used to dynamically construct cascade filters (superposition of several filters)

	//Describes single level of cascade filter
	class CascadeFilterLevel : public Entity
	{
	private:
		bool is_initialized;	//equals 'true' if cascade level has been initialized. Equals 'false' otherwise.
		Framebuffer auxiliary_framebuffer;	//auxiliary framebuffer used for rendering of intermediate results produced at this level of cascade filter
		std::list<AbstractSSFilter*> level_filter_list;	//list of filters that form this cascade level
		std::list<ImmutableTexture2D> output_textures;	//list of textures containing output at this level of cascade filter


		//The following fields and types describe texture size and format used for the output from this cascade level
		enum class tag_color_width : uint8_t { _16bit = 16U, _32bit = 32U };

		uvec2 uv2OutputResolution;	//resolution used by the output textures at this level of cascade filter
		std::bitset<4> output_color_bits;	//bit set determining which among R, G, B, and A color components, in this order, should be used for the output
		tag_color_width output_color_width;	//number of bits that encode output color in the cascade filter level


	public:
		typedef tag_color_width ColorWidth;

		//Default initialization constructor
		CascadeFilterLevel();

		//Initializes new cascade filter level with the output data defined using the given format and resolution (resolution is defined by a 2D vector containing width and 
		//height, in this order, represented in texels).
		//Note! Color components can only be included into the output in "consequent" order. In other words only the following combinations of colors are possible:
		//R, RG, RGB, and RGBA. If provided combination is different, then it is automatically augmented to match into allowed list. For instance, if color components,
		//which should be included into the output are R and B, then the output will contain R, G, and B components. Analogically, if output is required to include G and A,
		//then in practice it will contain all R, G, B, and A components.
		CascadeFilterLevel(const uvec2 output_resolution,
			bool has_red_channel = true, bool has_green_channel = true, bool has_blue_channel = true, bool has_alpha_channel = true,
			ColorWidth output_color_width = ColorWidth::_16bit);



		//Applies new value to be used as the resolution of the output textures at this level of cascade filter. The resolution is defined by a 2D vector
		//containing width and height, in this order, represented in texels
		void setOutputResolution(const uvec2& output_resolution);

		//Returns output resolution of the cascade level. The resolution is a 2D vector containing width and height, in this order, represented in texels
		uvec2 getOutputResolution() const;

		//Defines, which color components should be included into the output. Note that the components can only be added into the output in "consequent" order. 
		//In other words only the following combinations of colors are possible: R, RG, RGB, and RGBA. If provided combination is different, then it is automatically 
		//augmented to match into allowed list. For instance, if color components, which should be included into the output are R and B, then the output will contain 
		//R, G, and B components. Analogically, if output is required to include G and A, then in practice it will contain all R, G, B, and A components.
		void setOutputColorComponents(bool has_red_channel, bool has_green_channel, bool has_blue_channel, bool has_alpha_channel);

		//Returns, which color components has been factually included into the output of the cascade level. The returned value is packed into 4D boolean vector,
		//where a component of the vector is set if the corresponding color component has been added to the output, and the correspondence is defined
		//by usual ordering, i.e. R, G, B, and A
		bvec4 getOutputColorComponents() const;

		//Defines bit with that should be used to store colors in the output textures
		void setOutputColorBitWidth(ColorWidth out_color_width);

		//Returns output color bit width
		ColorWidth getOutputColorBitWidth() const;



		//Registers new filter to the cascade filter level
		void addFilter(AbstractSSFilter* p_filter);

		//Removes the first filter from the cascade level
		void removeFirstFilter();

		//Removes the last filter from the cascade level
		void removeLastFilter();

		//Retrieves filter located at position 'index' in the level and returns a pointer to its interface
		AbstractSSFilter* retrieveFilter(uint32_t index);

		//Retrieves filter located at position 'index' in the level and returns a pointer to its interface
		const AbstractSSFilter* retrieveFilter(uint32_t index) const;

		//Returns number of filters in the cascade level
		uint32_t getNumberOfFilters() const;



		//Initializes all filters within the cascade level. Note that initialization must be repeated each time when resolution of the screen,
		//storage format of the cascade level output textures, or number of filters in the level get altered
		void initialize();

		//Returns 'true' if the cascade level has been initialized; returns 'false' otherwise
		bool isInitialized() const;

		//Runs all filters in the filter cascade level. Returns 'true' if all filters in the level has been executed successfully. Returns 'false' otherwise
		bool pass(const AbstractProjectingDevice& projecting_device);

		//Returns alias object referring to the output texture generated by a filter, which has the given index at this cascade level
		ImmutableTexture2D getTextureOutput(uint32_t index);
	};


	//Describes cascade filter object
	class CascadeFilter : public AbstractSSFilter
	{
	private:
		//Describes data flow redirection for an input channel of cascade filter level from an output channel of one of the preceding levels
		struct tag_DataFlow
		{
			uint32_t input_channel_index;
			uint32_t output_channel_level;
			uint32_t output_channel_index;

			tag_DataFlow();
			tag_DataFlow(uint32_t in_channel, uint32_t out_level, uint32_t out_channel);
		};

		
		//Contains levels of the cascade filter
		std::vector<CascadeFilterLevel> levels;

		//Describes the way data flow will be redirected for the inputs at each level of the cascade (except the base level, which may not have input redirections)
		std::vector<std::list<tag_DataFlow>> level_data_flow_redirection_tables;	

		//Canvas used to output result produced by the cascade
		FullscreenRectangle result_canvas;

		//Resolution of the output being applied to every cascade level
		uvec2 uv2CommonLevelOutputResolution;

		//Equals 'true' of all cascade levels should use the same output resolution determined by the value of uv2CommonLevelOutputResolution
		bool levels_use_common_output_reolution;

		//Equals 'true' if the cascade filter has been initialized; equals 'false' otherwise
		bool is_initialized;


		protected:
			//Cascade filters do not have own texture sources besides the sources belonging to the filters that have been attached to the cascade.
			//However, those sources do not count as the sources of cascade filter itself. Hence, calling this function with any value
			//of the index will raise an exception
			void setTextureSource(uint32_t index, const ImmutableTexture2D& _2dtexture) override;

			//Cascade filters do not have own texture sources besides the sources belonging to the filters that have been attached to the cascade.
			//However, those sources do not count as the sources of cascade filter itself. Hence, calling this function with any value
			//of the index will raise an exception
			ImmutableTexture2D getTextureSource(uint32_t index) const override;

		public:
			typedef tag_DataFlow DataFlow;

			//Default initializer
			CascadeFilter();

			//Creates new cascade filter with base level
			CascadeFilter(const CascadeFilterLevel& base_filter_level);

			//Defines base level for the cascade filter. Note, that the base level should always be added the first. 
			//Calling this function has no effect if the base level has already been added
			void addBaseLevel(const CascadeFilterLevel& base_filter_level);

			//Adds new filtering level to the cascade filter. Note, that this function can only be used after calling addBaseLevel().
			//Calling this function before calling addBaseLevel() has no effect but is not considered erroneous.
			void addLevel(const CascadeFilterLevel& filter_level, const std::list<DataFlow>& data_redirection_table);

			//Defines if all levels should use common output resolution
			void useCommonOutputResolution(bool flag);

			//Checks if all filter levels have common output resolution overriding set
			bool isCommonOutputResolutionInUse() const;

			//Sets value to be used as the common output resolution for all filter levels
			void setCommonOutputResolutionValue(const uvec2& resolution);

			//Returns current value used as the common output resolution for cascade levels
			uvec2 getCommonOutputResolutionValue() const;

			//Initializes cascade filter
			void initialize() override;

			//Returns 'true' if the cascade filter has been initialized; returns 'false' otherwise
			bool isInitialized() const override;

			//Performs filtering pass
			bool pass(const AbstractProjectingDevice& projecting_device, AbstractRenderingDevice& render_target) override;

			//Returns number of input channels for the cascade
			uint32_t getNumberOfInputChannels() const override;
	};

}


#define TW__SSFILTER__
#endif